# -*- coding: utf-8 -*-
"""
Script de Previs√£o Futura - Projeto TJGO
Usa o melhor modelo (Prophet) para fazer previs√µes dos pr√≥ximos meses
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
import os

# Optional imports
try:
    from prophet import Prophet
    HAS_PROPHET = True
except Exception:
    HAS_PROPHET = False
    Prophet = None

warnings.filterwarnings('ignore')

class FutureForecaster:
    """
    Classe para fazer previs√µes futuras usando o melhor modelo
    """
    
    def __init__(self, data_path='./data/processed_test/data_processed_test.csv'):
        """
        Inicializa o previsor
        
        Args:
            data_path (str): Caminho para os dados processados
        """
        self.data_path = data_path
        self.data = None
        self.model = None
        self.forecast = None
        
    def load_data(self):
        """
        Carrega os dados processados
        """
        print("üìä Carregando dados processados...")
        
        try:
            self.data = pd.read_csv(self.data_path, index_col='DATA', parse_dates=True)
            print(f"‚úÖ Dados carregados: {len(self.data)} observa√ß√µes")
            print(f"Per√≠odo: {self.data.index.min().strftime('%Y-%m')} a {self.data.index.max().strftime('%Y-%m')}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados: {e}")
            return False
    
    def train_best_model(self):
        """
        Treina o melhor modelo (Prophet) com todos os dados dispon√≠veis
        """
        if not HAS_PROPHET:
            print("‚ùå Prophet n√£o dispon√≠vel. Instale: pip install prophet")
            return False
            
        print("üîÑ Treinando modelo Prophet (melhor modelo)...")
        
        try:
            # Preparar dados para Prophet
            prophet_data = self.data.reset_index()
            prophet_data = prophet_data.rename(columns={'DATA': 'ds', 'TOTAL_CASOS': 'y'})
            
            # Inicializar modelo Prophet
            self.model = Prophet(
                yearly_seasonality=True,
                weekly_seasonality=False,
                daily_seasonality=False,
                seasonality_mode='additive',
                interval_width=0.95  # Intervalo de confian√ßa de 95%
            )
            
            # Adicionar vari√°veis ex√≥genas (apenas econ√¥micas tradicionais)
            exog_vars = ['TAXA_SELIC', 'IPCA', 'TAXA_DESOCUPACAO', 'INADIMPLENCIA']
            
            for var in exog_vars:
                if var in prophet_data.columns:
                    self.model.add_regressor(var)
                    print(f"  ‚úÖ Adicionada vari√°vel ex√≥gena: {var}")
            
            # Treinar modelo com todos os dados
            self.model.fit(prophet_data)
            print("‚úÖ Modelo Prophet treinado com sucesso!")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro no treinamento: {e}")
            return False
    
    def make_forecast(self, months_ahead=12):
        """
        Faz previs√µes para os pr√≥ximos meses
        
        Args:
            months_ahead (int): N√∫mero de meses para prever
        """
        if self.model is None:
            print("‚ùå Modelo n√£o treinado. Execute train_best_model() primeiro.")
            return None
            
        print(f"üîÆ Fazendo previs√µes para os pr√≥ximos {months_ahead} meses...")
        
        try:
            # Criar dataframe futuro
            future = self.model.make_future_dataframe(periods=months_ahead, freq='MS')
            
            # Adicionar vari√°veis ex√≥genas para o per√≠odo futuro
            # Para simplicidade, vamos usar os √∫ltimos valores conhecidos
            exog_vars = ['TAXA_SELIC', 'IPCA', 'TAXA_DESOCUPACAO', 'INADIMPLENCIA']
            
            for var in exog_vars:
                if var in self.data.columns:
                    # Usar o √∫ltimo valor conhecido para todas as previs√µes futuras
                    last_value = self.data[var].iloc[-1]
                    future[var] = last_value
                    print(f"  üìà {var}: usando √∫ltimo valor = {last_value:.2f}")
            
            # Fazer previs√µes
            self.forecast = self.model.predict(future)
            
            # Extrair apenas as previs√µes futuras
            future_forecast = self.forecast.tail(months_ahead)
            
            print("‚úÖ Previs√µes geradas com sucesso!")
            print(f"Per√≠odo das previs√µes: {future_forecast['ds'].iloc[0].strftime('%Y-%m')} a {future_forecast['ds'].iloc[-1].strftime('%Y-%m')}")
            
            return future_forecast
            
        except Exception as e:
            print(f"‚ùå Erro na previs√£o: {e}")
            return None
    
    def plot_forecast(self, months_ahead=12, save_plot=True):
        """
        Plota as previs√µes com dados hist√≥ricos
        
        Args:
            months_ahead (int): N√∫mero de meses para mostrar
            save_plot (bool): Se deve salvar o gr√°fico
        """
        if self.forecast is None:
            print("‚ùå Nenhuma previs√£o dispon√≠vel. Execute make_forecast() primeiro.")
            return
            
        print("üìà Gerando visualiza√ß√£o das previs√µes...")
        
        try:
            # Configurar estilo
            plt.style.use('seaborn-v0_8')
            fig, ax = plt.subplots(figsize=(15, 8))
            
            # Plotar dados hist√≥ricos
            ax.plot(self.data.index, self.data['TOTAL_CASOS'], 
                   label='Dados Hist√≥ricos', linewidth=2, color='blue', alpha=0.8)
            
            # Plotar previs√µes
            future_data = self.forecast.tail(months_ahead)
            ax.plot(future_data['ds'], future_data['yhat'], 
                   label='Previs√£o', linewidth=3, color='red', linestyle='--')
            
            # Plotar intervalo de confian√ßa
            ax.fill_between(future_data['ds'], 
                           future_data['yhat_lower'], 
                           future_data['yhat_upper'],
                           alpha=0.3, color='red', label='Intervalo de Confian√ßa 95%')
            
            # Configurar gr√°fico
            ax.set_title('Previs√£o de Casos TJGO - Pr√≥ximos 12 Meses', fontsize=16, fontweight='bold')
            ax.set_xlabel('Data', fontsize=12)
            ax.set_ylabel('Total de Casos', fontsize=12)
            ax.legend(fontsize=12)
            ax.grid(True, alpha=0.3)
            
            # Rotacionar labels do eixo x
            plt.xticks(rotation=45)
            plt.tight_layout()
            
            if save_plot:
                os.makedirs('./reports_test', exist_ok=True)
                plt.savefig('./reports_test/forecast_future.png', dpi=300, bbox_inches='tight')
                print("‚úÖ Gr√°fico salvo em ./reports_test/forecast_future.png")
            
            plt.show()
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar gr√°fico: {e}")
    
    def save_forecast(self, months_ahead=12, filename='forecast_results.csv'):
        """
        Salva as previs√µes em CSV
        
        Args:
            months_ahead (int): N√∫mero de meses para salvar
            filename (str): Nome do arquivo
        """
        if self.forecast is None:
            print("‚ùå Nenhuma previs√£o dispon√≠vel.")
            return
            
        print(f"üíæ Salvando previs√µes em {filename}...")
        
        try:
            # Extrair previs√µes futuras
            future_data = self.forecast.tail(months_ahead)
            
            # Criar DataFrame com informa√ß√µes relevantes
            forecast_df = pd.DataFrame({
                'Data': future_data['ds'],
                'Previsao_Casos': future_data['yhat'].round(0),
                'Limite_Inferior': future_data['yhat_lower'].round(0),
                'Limite_Superior': future_data['yhat_upper'].round(0),
                'Intervalo_Confianca': (future_data['yhat_upper'] - future_data['yhat_lower']).round(0)
            })
            
            # Salvar
            os.makedirs('./reports_test', exist_ok=True)
            filepath = f'./reports_test/{filename}'
            forecast_df.to_csv(filepath, index=False)
            
            print(f"‚úÖ Previs√µes salvas em {filepath}")
            print("\nüìä Resumo das Previs√µes:")
            print(forecast_df.to_string(index=False))
            
            return forecast_df
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar: {e}")
            return None
    
    def generate_insights(self, months_ahead=12):
        """
        Gera insights das previs√µes
        
        Args:
            months_ahead (int): N√∫mero de meses analisados
        """
        if self.forecast is None:
            print("‚ùå Nenhuma previs√£o dispon√≠vel.")
            return
            
        print("\nüîç INSIGHTS DAS PREVIS√ïES:")
        print("="*50)
        
        try:
            future_data = self.forecast.tail(months_ahead)
            
            # Estat√≠sticas b√°sicas
            mean_forecast = future_data['yhat'].mean()
            min_forecast = future_data['yhat'].min()
            max_forecast = future_data['yhat'].max()
            
            print(f"üìà M√©dia prevista: {mean_forecast:.0f} casos/m√™s")
            print(f"üìâ M√≠nimo previsto: {min_forecast:.0f} casos")
            print(f"üìä M√°ximo previsto: {max_forecast:.0f} casos")
            
            # Comparar com dados hist√≥ricos
            historical_mean = self.data['TOTAL_CASOS'].mean()
            historical_std = self.data['TOTAL_CASOS'].std()
            
            print(f"\nüìä Compara√ß√£o com hist√≥rico:")
            print(f"  M√©dia hist√≥rica: {historical_mean:.0f} casos/m√™s")
            print(f"  Desvio padr√£o hist√≥rico: {historical_std:.0f}")
            
            # Tend√™ncia
            first_forecast = future_data['yhat'].iloc[0]
            last_forecast = future_data['yhat'].iloc[-1]
            trend = last_forecast - first_forecast
            
            if trend > 0:
                print(f"üìà Tend√™ncia: AUMENTO de {trend:.0f} casos ao longo do per√≠odo")
            elif trend < 0:
                print(f"üìâ Tend√™ncia: DIMINUI√á√ÉO de {abs(trend):.0f} casos ao longo do per√≠odo")
            else:
                print("‚û°Ô∏è Tend√™ncia: EST√ÅVEL")
            
            # M√™s com maior previs√£o
            max_month_idx = future_data['yhat'].idxmax()
            max_month = future_data.loc[max_month_idx, 'ds']
            max_value = future_data.loc[max_month_idx, 'yhat']
            
            print(f"\nüéØ M√™s com maior previs√£o: {max_month.strftime('%Y-%m')} ({max_value:.0f} casos)")
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar insights: {e}")

def main():
    """
    Fun√ß√£o principal para executar previs√µes futuras
    """
    print("üîÆ PREVIS√ïES FUTURAS - PROJETO TJGO")
    print("="*50)
    print("Usando o melhor modelo: Prophet (modelo teste)")
    print("Configura√ß√£o: dados 2015+, vari√°veis econ√¥micas tradicionais")
    print("="*50)
    
    # Inicializar previsor
    forecaster = FutureForecaster()
    
    # Carregar dados
    if not forecaster.load_data():
        return
    
    # Treinar modelo
    if not forecaster.train_best_model():
        return
    
    # Fazer previs√µes para 12 meses
    forecast_data = forecaster.make_forecast(months_ahead=12)
    
    if forecast_data is not None:
        # Gerar visualiza√ß√£o
        forecaster.plot_forecast(months_ahead=12)
        
        # Salvar resultados
        forecaster.save_forecast(months_ahead=12)
        
        # Gerar insights
        forecaster.generate_insights(months_ahead=12)
        
        print("\n‚úÖ Previs√µes futuras conclu√≠das com sucesso!")
        print("üìÅ Arquivos gerados em ./reports_test/")
        print("  - forecast_future.png (gr√°fico)")
        print("  - forecast_results.csv (dados)")
    
    return forecaster

if __name__ == "__main__":
    forecaster = main()
